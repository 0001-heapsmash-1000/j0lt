
struct __attribute__((packed, aligned(1))) J0LT_UDPHDR
{
#if __BYTE_ORDER == __BIG_ENDIAN
    uint64_t    srcprt : 16;
    uint64_t    dstprt : 16;
    uint64_t    len : 16;
    uint64_t    checksum : 16;
#endif

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    uint64_t    checksum : 16;
    uint64_t    len : 16;
    uint64_t    dstprt : 16;
    uint64_t    srcprt : 16;
#endif
};

#define     FLAGS_DF 0b010
#define     FLAGS_MF 0b001

struct __attribute__((packed, aligned(1))) J0LT_TOS
{
#if __BYTE_ORDER == __BIG_ENDIAN
    uint8_t     precedence : 3;
    uint8_t     strm : 1;
    uint8_t     reliability : 2;
    uint8_t     sr : 1;
    uint8_t     speed : 1;
#endif

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    uint8_t     speed : 1;
    uint8_t     sr : 1;
    uint8_t     reliability : 2;
    uint8_t     strm : 1;
    uint8_t     precedence : 3;
#endif
};

#define     IHL_MIN 5
#define     IHL_MAX 15

struct __attribute__((packed, aligned(1))) J0LT_PSEUDOHDR
{
    uint32_t sourceaddr;
    uint32_t destaddr;

#if __BYTE_ORDER == __BIGENDIAN 
    uint32_t zero : 8;
    uint32_t protocol : 8;
    uint32_t udplen : 16;
#endif

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    uint32_t udplen : 16;
    uint32_t protocol : 8;
    uint32_t zero : 8;
#endif
};

struct __attribute__((packed, aligned(1))) J0LT_IPHDR
{
#if __BYTE_ORDER == __BIG_ENDIAN
    uint8_t     version : 4;    // format of the internet header (ipv4)
    uint8_t     ihl : 4;        // len of internet header in 32 bit words,
                                // points to the beginning of the data.
#endif

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    uint8_t     ihl : 4;
    uint8_t     version : 4;
#endif
    struct J0LT_TOS tos;
    uint16_t    total_len; // length of the datagram

    uint16_t    id;
#if __BYTE_ORDER == __BIG_ENDIAN
    uint16_t    flags : 3;
    uint16_t    offset : 13;
#endif 

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    uint16_t    offset : 13;
    uint16_t    flags : 3;
#endif 
    uint8_t     ttl; // maximum time
    uint8_t     protocol;
    uint16_t    checksum;
    uint32_t    sourceaddr;
    uint32_t    destaddr;
};

#define     IPVER 4
#define     ID 0x1337
#define     QR 0 // query (0), response (1).

typedef enum __opcode__ {
    OP_QUERY = 0,
    OP_IQUERY = 1,
    OP_STATUS = 2,
    OP_NOTIFY = 3,
    OP_UPDATE = 4
} opcode;
#define     OPCODE OP_QUERY

#define     AA 0 // Authoritative Answer
#define     TC 0 // TrunCation
#define     RD 1 // Recursion Desired   (END OF BYTE 3)
#define     RA 0 // Recursion Available
#define     Z  0 // Reserved
#define     AD 1 // Authentic Data (DNS-SEC)
#define     CD 0 // Checking Disabled (DNS-SEC)

typedef enum __rcode__ {
    RC_NO_ER = 0,
    RC_FMT_ERR = 1,
    RC_SRVR_FA = 2,
    RC_NAME_ER = 3,
    RC_NOT_IMP = 4,
    RC_REFUSED = 5
} rcode;
#define     RCODE RC_NO_ER

#define     QDCOUNT 1 // num entry question
#define     ANCOUNT 0 // num RR answer
#define     NSCOUNT 0 // num NS RR 
#define     ARCOUNT 0 // num RR additional

struct __attribute__((packed, aligned(1))) J0LT_DNSHDR
{
    uint16_t        id : 16;
#if __BYTE_ORDER == __BIG_ENDIAN
    // third byte
    uint8_t     qr : 1;
    uint8_t     opcode : 4;
    uint8_t     aa : 1;
    uint8_t     tc : 1;
    uint8_t     rd : 1;
    // fourth byte
    uint8_t     ra : 1;
    uint8_t     z : 1;
    uint8_t     ad : 1;
    uint8_t     cd : 1;
    uint8_t     rcode : 4;
#endif

#if __BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __PDP_ENDIAN
    // third byte
    uint8_t     rd : 1;
    uint8_t     tc : 1;
    uint8_t     aa : 1;
    uint8_t     opcode : 4;
    uint8_t     qr : 1;
    // fourth byte
    uint8_t     rcode : 4;
    uint8_t     cd : 1;
    uint8_t     ad : 1;
    uint8_t     z : 1;
    uint8_t     ra : 1;
#endif
    // remaining bytes
    uint16_t    qdcount : 16;
    uint16_t    ancount : 16;
    uint16_t    nscount : 16;
    uint16_t    arcount : 16;
};

typedef enum __type__ {
    T_A = 1,// host address
    T_NS = 2,// authoritative name server
    T_MD = 3,// mail destination
    T_MF = 4,// mail forwarder
    T_CNAME = 5,// canonical name for alias
    T_SOA = 6,// start of zone authority
    T_MB = 7,// mailbox domain name
    T_MG = 8,// mail group member
    T_MR = 9,// mail rename domain name
    T_NULL = 10, // null RR
    T_WKS = 11, // service description
    T_PTR = 12, // a domain name pointer
    T_HINFO = 13, // host information
    T_MINFO = 14, // mail list information
    T_MX = 15, // mail exchange
    T_TXT = 16, // text strings
    QT_AXFR = 252, // transfer of entire zone
    QT_MAILB = 253, // mailbox records 
    QT_MAILA = 254, // req mail agent RRs
    QT_ALL = 255 // req all records
} type;
#define     QTYPE QT_ALL

typedef enum __class__ {
    C_IN = 1, // the Internet
    C_CS = 2, // the CSNET class
    C_CH = 3, // the CHAOS class
    C_HS = 4, // Hesiod [Dyer 87]
    QC_ALL = 255, // anyclass
} class;
#define     QCLASS QC_ALL